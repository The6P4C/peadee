# Cable
Processor looks like a [GD32F1x0](https://www.gigadevice.com/microcontroller/gd32f130c4t6/)
- `DBG_ID` register at `0xE004_2000` has value `0x13030410`
	- `REV_ID = 0x1303`
	- `DEV_ID = 0x410`
- IRQ 37 for USB interrupts matches table in user manual
- [whitequark's teardown](https://twitter.com/whitequark/status/1336336420663783426)
shows it's a GD32F150G8
	- 64KB flash
	- 8KB SRAM

PD Controller looks like a [FUSB302](https://www.onsemi.com/products/interfaces/usb-type-c/fusb302)
or clone
- Communication over I2C1

| Pin | Function |
|---|---|
| PA0 | I2C to PD controller |
| PA1 | I2C to PD controller |
| PA2 | PD controller interrupt line - TBC |
| PA5 | Programming adapter signal |
| PA6 | ??? - used in SPI-ish logic |
| PB3 | RGB LED (red) |
| PB4 | RGB LED (blue) |
| PB5 | RGB LED (green) |

All RGB LED signals are active low - LED is turned on if output is turned
off.

When the adapter is plugged into the cable, it presents a 10 kHz square wave to
PA5 which the bootloader (and app?) sense to detect if the bootloader should
continue running (signal was present) or the application should run (signal not
present after a set amount of time)

Some serial thing reads from PA6 whenever an edge is detected on EXTI line 3 and
creates an 8-bit string from it
- If it's been more than 8ms since the last edge, throw the data away and
configure PA5 and PA6 as inputs
	- No pull on PA5, pull-up on PA6
- If 8 bits have been read, detect:
	- `A8 = 1010 1000` -> Path A
	- `AC = 1010 1100` -> Path A
	- `A4 = 1010 0100` -> Path B
	- `A6 = 1010 0110` -> Path A
	- `A2 = 1010 0010` -> Path B
	- `B6 = 1011 0110` -> Path B
	- Anything else    -> Path A
	- Store 0x62 in mask
- If greater than 16 bits have been read:
	- If exactly 17 bits have been read, read mask and:
		- `48 = 0100 1000` -> Path A
		- `68 = 0110 1000` -> Path A
		- `70 = 0111 0000` -> Path A
		- `78 = 0111 1000` -> Path A
		- `62 = 0110 0010` -> Path A
		- Anything else    -> Path B
		- After taking A/B:
			- Delay
			- Configure as outputs + low
			- Delay
			- Configure as AF (SPI??)
	- Otherwise:
		- Configure as AF
	- If top (?) bit of data is set -> Path B
	- Otherwise -> Path A
- Note:
	- Path A: configure PA5 and PA6 as outputs, set HIGH
	- Path B: configure PA5 and PA6 as outputs, set LOW

# Programming Adapter
Numbered left to right (viewing component side), where left = WITRN logo, right
= PDC002 text

| Pin | Function |
|---|---|
| 6 | USB D+ (through 22 ohm resistor), 1k5 ohm pull-up to 3V3 |
| 7 | USB D- (through 22 ohm resistor) |
| 8 | Adapter 10 kHz signal (through 0 ohm link) |

10 kHz signal is generated by the little MCU (silkscreen 360A0 76345), which
also drives the blinking LED on the board
